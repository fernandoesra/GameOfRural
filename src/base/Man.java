package base;

import main.Inventory;
import map.Board;
import resources.Money;
import utils.AleatoricName;
import utils.Movement;

/**
 * Base object to create differents type of human beigns. Each Man have some
 * unique attributes:
 * 
 * <p>
 * <b>- name:</b> A random name generated by the object AleatoricName<br>
 * <b>- ID:</b> A unique ID for each Man<br>
 * <b>- HP:</b> Starting life pointes<br>
 * <b>- money:</b> A Money object with the amount parameter of how much money the
 * man have<br>
 * <b>- mapX:</b> The X position of the Man in the board<br>
 * <b>- mapY:</b> The Y position of the Man in the board<br>
 * <b>- speed:</b> How much squares the Man move on the board<br>
 * <b>- icon:</b> The icon of the man, used to draw the man on the toString() method<br>
 * <b>- inventory:</b> A Inventory object to store all the items the Man have<br>
 * 
 * <p>
 * The <b>mapX</b> and <b>mapY</b> attributes of the man does not place the
 * object on the map. To do that it is necessary to use the next method of Board:<br>
 * <b>addSomething(Object <i>Man</i>, <i>mapX</i>, <i>mapY</i>)</b>
 * 
 * <p>
 * Also implements the <b>Movement interface</b> to allow the man move on the board.
 * 
 * @author Fernando Tarrino del Pozo (FernandoEsra)
 * @see utils.AleatoricName
 * @see resources.Money
 * @see map.Board
 * @see main.Inventory
 * @see utils.Movement
 * 
 */
public class Man implements Comparable, Movement{
	
	// Attributes
	protected String name;
	protected int ID;
	protected int HP;
	protected Money money;
	protected int mapX;
	protected int mapY;
	protected int speed;
	public String icon;
	public Inventory inventory;
	
	// Constructor
	public Man() {};
	
	/**
	 * Its it possible to change the lenght of the name by change the <b>minName</b>
	 * and <b>maxName</b> variables inside the constructor. Default its between 3
	 * and 10
	 * 
	 * @param ID    The ID of the Man. For the correct execution of the methods it
	 *              is recommended not to repeat IDs.
	 * @param HP	Starting life points.
	 * @param money	A Money object with the starting money.
	 * @param mapX	The starting X position on the board.
	 * @param mapY	The starting Y position on the board.
	 * @param speed	The starting speed (squares per turn).
	 * @param icon	The icon of this man.
	 */
	public Man(int ID, int HP, Money money, int mapX, int mapY, int speed, String icon) {
		int minName = 3;
		int maxName = 10;
		AleatoricName newName = new AleatoricName(minName,maxName);
		this.name = newName.toString();
		this.ID = ID;
		this.HP = HP;
		this.money = money;
		this.mapX = mapX;
		this.mapY = mapY;
		this.speed = speed;
		this.icon = icon;
		this.inventory = new Inventory();
	}
	
	// Get and Set
	public String getName() {
		return this.name;
	}
	
	public int getID() {
		return ID;
	}
	
	public void setID(int iD) {
		ID = iD;
	}
	
	public int getHP() {
		return HP;
	}

	public void setHP(int hP) {
		HP = hP;
	}

	public Money getMoney() {
		return money;
	}

	public void setMoney(Money money) {
		this.money = money;
	}

	public int getMapX() {
		return mapX;
	}

	public void setMapX(int mapX) {
		this.mapX = mapX;
	}

	public int getMapY() {
		return mapY;
	}

	public void setMapY(int mapY) {
		this.mapY = mapY;
	}

	public int getSpeed() {
		return speed;
	}

	public void setSpeed(int speed) {
		this.speed = speed;
	};
	
	public String getIcon() {
		return icon;
	}
	
	public void setIcon(String icon) {
		this.icon = icon;
	}
	
	// Methods
	public String toString() {
		return name + ", with ID (" + ID + ") have " + HP + " life points.\n" + "Have " + money
				+ " ruralcoins, Moves " + speed + " square per turn.\n"
				+ "It is currently at (" + mapX + ").(" + mapY + ")\n"
				+ "Its icon is: " + icon + "\n" + inventory;
	};
	
	@Override
	public boolean equals(Object obj) {
		// Do not compare the money, the position on the map an the actual life.
		boolean equals = false;
		Man other = (Man) obj;
		if(
			other.name.compareTo(this.name) == 0 &&
			other.ID == this.ID &&
			other.speed == this.speed &&
			other.icon == this.icon
			)
		{
			equals = true;
		}

		return equals;
	}

	@Override
	public int compareTo(Object obj) {
		// Compare the IDs
		int comparable = 0;
		Man other = (Man) obj;
		comparable = this.ID - other.ID;
		return comparable;
		
	}
	
	/**
	 * This method read a Money object and add the money to the money of this
	 * man.<br>
	 * <b>Important:</b> This method does not subtract money of the object that is
	 * passed as input parameter.
	 * 
	 * @param newMoney A Money object to read the amount and add that amount to te
	 *                 actual money of the man
	 */
	public void addMoney(Money newMoney) {
		this.money.setQuantity(this.money.getQuantity() + newMoney.getQuantity());
	}
	
	/**
	 * This method subtract a double valor of the actual money of the man. But first
	 * check if it possible (the man have enough money)
	 * 
	 * @param totalToSubtract A double quantity to subtract for the actual money.
	 * @return <b><i>false</i></b> if the man does not have enough money<br>
	 *         <b><i>true</i></b> If it has been possible to make the operation
	 */
	public boolean subtractMonet(double totalToSubtract) {
		boolean possibleToSubtract = false;
		if (this.money.getQuantity() - totalToSubtract >= 0) {
			money.setQuantity(this.money.getQuantity() - totalToSubtract);
			possibleToSubtract = true;
		}
		return possibleToSubtract;
	}
	
	/**
	 * Update the (newX).(newY) coordinates of the man. This method does not check
	 * anything. Like if it is possible to place the update man on the new
	 * coordinates. That should be done with board methods.
	 * 
	 * @param newX A new value for this.newX
	 * @param newY A new value for this.newY
	 */
	public void update(int newX, int newY) {
		this.mapX = newX;
		this.mapY = newY;
	}
	
	@Override
	public boolean up(Board board) {
		boolean movement = false;
		
		if (board.validPosition(mapX - 1, mapY)) {
			movement = true;
		}
		
		return movement;
	}

	@Override
	public boolean down(Board board) {
		boolean movement = false;

		if (board.validPosition(mapX + 1, mapY)) {
			movement = true;
		}

		return movement;
	}

	@Override
	public boolean right(Board board) {
		boolean movement = false;

		if (board.validPosition(mapX, mapY + 1)) {
			movement = true;
		}

		return movement;
	}

	@Override
	public boolean left(Board board) {
		boolean movement = false;

		if (board.validPosition(mapX, mapY - 1)) {
			movement = true;
		}

		return movement;
	}

	@Override
	public boolean toPosition(Board board, int posX, int posY) {
		boolean movement = false;

		if (board.validPosition(posX, posY)) {
			movement = true;
		}

		return movement;
	}

}
